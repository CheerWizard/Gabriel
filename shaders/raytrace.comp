#version 460 core

#include core.glsl

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D outColor;

const vec4 clearColor = vec4(0, 0, 0, 1.0);

#include camera.glsl

layout(std140, binding = 10) uniform SphereBuffer {
    vec4 sphereCenterRadius;
};

layout(std140, binding = 11) uniform RayBuffer {
    vec4 rayOrigin;
    vec4 rayDir;
};

void main() {
    // get pixel coord by global invocation
    vec4 pixel;
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(outColor);

    // transform into [-1, 1]
    float x = -(float(uv.x * 2 - dims.x) / dims.x);
    float y = -(float(uv.y * 2 - dims.y) / dims.y);

    // create ray
    vec3 ro = vec3(x, y, rayOrigin.z);
    vec3 rd = rayDir.xyz;

    // create sphere
    vec3 sc = sphereCenterRadius.xyz;
    float sr = sphereCenterRadius.w;

    // solve intersection equation of ray vs sphere
    vec3 rc = ro - sc;
    float a = 1; // dot(d, d) = 1;
    float b = dot(rd, rc);
    float c = dot(rc, rc) - sr * sr;
    float D = b * b - c;

    // determine intersection state
    if (D >= 0) {
        // intersection scalar relative to ray origin
        float t1 = (-b - sqrt(D)) / 2;
        float t2 = (-b + sqrt(D)) / 2;
        // intersection vertices
        vec3 i1 = ro + rd * t1;
        vec3 i2 = ro + rd * t2;
        // intersection pixel color
        vec3 c1 = normalize(i1 - sc) + 1.0 / 2.0;
        vec3 c2 = normalize(i2 - sc) + 1.0 / 2.0;

        pixel = vec4(x + 1 / 2.0, y + 1 / 2.0, 1.0, 1.0);
    } else {
        pixel = clearColor;
    }

    imageStore(outColor, uv, pixel);
}